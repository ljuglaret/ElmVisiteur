<!DOCTYPE html>
<meta charset="UTF-8">
<html>
    <head>
<title align="center"> Pattern Visiteur Elm/java</title>
    <body><textarea theme="Journal">

<html>

 
# De java a elm

---

## Java c est (trop de ) classes

```javascript
 class Monkey { shout() { console.log('Ooh oo aa aa!') } accept(operation) { operation.visitMonkey(this) } }



//Et ainsi de suite pour chaque animal

//Maintenant le visiteur

const speak = { visitMonkey(monkey){ monkey.shout() }
}

//Et on visite ainsi de suite tous les animaux


//Et enfin son utilisation

const monkey = new Monkey()  monkey.accept(speak) 
```


 Que peut on remarquer?
C est très (trop) répétitif, et pas du tout pratique.

 Par exemple : que se passe t il pour ajouter un animal avec sa propre méthode "cri" ?
Et bien il faudra ajouter dans la variable speak 

```javascript

visitMonkey(monkey){ monkey.shout() }

```


 Et si l on veut ajouter un nouveau visiteur par exemple espèce ?
 Ça sera encore plus long puisque dans chaque classe correspondant un animal il faudra indiquer
.accept(espèce)



## case of, un visiteur comme un autre



Comment va t on faire en elm?
- Créer un type Animaux sous la forme d un record avec comme champs le nom le cri et l espèce.
- Chaque champs est un d un type particulier qu il faut aussi définir

```elm
type Animaux s  = Animal { nom : Nom, cri : Cri s, espece  : Espece}
``` 



Avantage

Pour ajouter une opération ou une variable c est très rapide.

Par exemple, pour ajouter un animal il faudra autoriser une nouvelle valeur à Nom.


```elm
type Nom = Chat 
           |Chien
           |Cheval -- Un nouvel animal a ete ajoute
```
Pour ajouter un nouveau visiteur comme l espérence de vie il faudra créer un nouveau type et l ajouter au record "Animaux" , fonctionne sur ce principe  : 
```elm
type Espece = Canide
            | Felin 
```

## Et ensuite ? 

Ensuite on peut simuler une calculatrice .   

Comment ?   

En definissant dans un premier temps les operations basiques   
en differenciant celles qui demandent un argument de celles    
qui en demandent deux.

```elm
type Bin = Plus 
             | Moins 
             | Fois 
             | Div      
             | Puiss    
 

type Trigo =  Cos       
            | Sin      
            | Tan      



type Expr a = OpeBin   { bin  : Bin , exprg : Expr a, exprd : Expr a}
            | Const     Float
            | Inconnue  a
            | OpeTrigo  { trigo : Trigo, expr : Expr a} 

type Var = X  
            | Y  
            | Z   

plus :  Expr a ->  Expr a -> Expr a
plus g d = OpeBin   { bin  = Plus , exprg = g  , exprd = d }
    
moins :  Expr a ->  Expr a -> Expr a
moins  g d = OpeBin   { bin  = Moins , exprg = g  , exprd = d }
    

fois :  Expr a ->  Expr a -> Expr a
fois g d = OpeBin   { bin  = Fois , exprg = g  , exprd = d }
    
div :  Expr a ->  Expr a -> Expr a
div g d = OpeBin   { bin  = Div , exprg = g  , exprd = d }


puiss :  Expr a ->  Expr a -> Expr a
puiss g d = OpeBin   { bin  = Puiss , exprg = g  , exprd = d }
    
cosinus :   Expr a -> Expr a
cosinus g = OpeTrigo   { trigo  = Cos , expr = g  }

sinus :   Expr a -> Expr a
sinus g = OpeTrigo   { trigo  = Sin , expr = g  }


tangente :   Expr a -> Expr a
tangente g = OpeTrigo   { trigo  = Tan , expr = g  }

```

Il faut ensuite pouvoir evaluer une expression en une liste de points.   
Par exemple : X^2 + Y^2 en (X,Y) = (2,3)

```elm

evalFold  : List (a, Float)  -> Expr a ->   Expr a
evalFold liste expr0 = 
        let
                eval : (a,Float) -> Expr a -> Expr a
                eval (var,val) exprE = 
                        case exprE of 
                                Const a -> Const a 
                                Inconnue xy-> if (xy == var) then Const val
                                        else Inconnue xy
                                OpeBin { bin,exprg,exprd}-> OpeBin{bin = bin, exprg = eval (var , val) exprg ,exprd = eval (var, val) exprd }
                                OpeTrigo  { trigo , expr } ->OpeTrigo {trigo = trigo, expr = eval (var,val) expr}
        in List.foldl  eval expr0 liste
```
Il ne reste plus qu a la calculer   

```elm   
calcul :  Expr a ->    Float
calcul   expr0 =
        case expr0 of 
                Const a -> a
                Inconnue xy-> 0
                OpeBin { bin,exprg,exprd}  -> 
                        case bin of 
                                Plus -> ( calcul exprg ) + ( calcul exprd)
                                Moins -> ( calcul exprg ) - ( calcul exprd)
                                Fois -> ( calcul exprg ) * ( calcul exprd)
                                Div -> ( calcul exprg ) / ( calcul exprd)
                                Puiss -> ( calcul exprg ) ^ ( calcul exprd)
                OpeTrigo  { trigo , expr } ->
                        case trigo of
                                Cos -> cos (calcul expr )
                                Sin -> sin (calcul expr)
                                Tan -> tan (calcul expr)
```
<ul class="pager">
<li class="next"><a href="suiteVisiteur.html">Un Maybe en Java →</a></li>
</ul> 

    </textarea>
        <script type="text/javascript" src="//lbesson.bitbucket.io/md/strapdown.min.js"></script>
    </body>
</html>
